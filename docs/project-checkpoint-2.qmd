---
format:
  revealjs:
    width: 1600
    height: 900
    scrollable: true
---

## Slide 1 — Problem statement & goal

**Problem:** Public pollen reports emphasize raw counts or broad categories that do not translate into an actionable, day‑to‑day severity forecast. Users need a simple, reliable 0–10 severity prediction driven by readily available weather and pollen inputs.

**Primary goal:** Predict daily pollen severity (0–10) for each pollen type and overall pollen from user‑provided weather metrics and daily pollen counts, targeting low error and providing interpretable feature drivers.

**Updated purpose/scope:** Due to the lack of reliable user symptom labels, the project focuses on predicting daily pollen severity (0–10) from user-provided weather inputs and daily pollen counts. Personalization (symptom forecasting) is not possible because labeled data is not available.

---

## Slide 2 — Updated Methodology & Progress
**Targets & labels**  
- Use AAAAI/NAB biological thresholds to convert raw pollen counts → 0–10 severity for Tree, Grass, Weed, Ragweed, and Total_Pollen.  
- Main reported target in this checkpoint: `Total_Pollen_Severity`.  

**Feature engineering**  
- Temporal: Day_of_Week; cyclical encodings for Month and Day‑of‑Year (sin/cos).  
- Core weather: TMAX, TMIN, TAVG, PRCP, AWND; plus Temp_Range and Is_Rainy.  
- Weather dynamics: 30‑day TAVG mean and Temp_Anomaly; seasonal rainfall cumsum; 30‑day Wind_Percentile.  
- Lags: Total_Pollen lag 1/3/7; TMAX and PRCP lags 1/3.
- Rolling: 3‑ and 7‑day rolling means/sums for pollen, temperature, rainfall.  
- Growing Degree Days: general + species‑specific (Tree/Grass/Weed) and annual cumsums.  
- Peak proximity: Gaussian proximity to seasonal peaks (≈ DOY 110/175/255).  
- Interactions: Temp_x_Spring, Temp_x_Summer, Rain_x_Wind.  

**Model & training**  
- Regressor: XGBoost 
- Split: time‑ordered 80/20 train/test; within‑train 90/10 validation for early stopping.  
- GPU auto‑detection with CPU fallback; predictions clipped to [0, 10].  

**Evaluation metrics**  
- MAE, RMSE, R², Weighted MAE (penalize high‑severity errors), Acc within ±1/±2, and High‑day MAE (≥7).  

---

## Slide 3 — Code Snippet 1
```python
def get_aaaai_thresholds():
    return {
        'Tree': {'thresholds': [0, 1, 15, 90, 1500]},
        'Grass': {'thresholds': [0, 1, 5, 20, 200]},
        'Weed': {'thresholds': [0, 1, 10, 50, 500]},
        'Ragweed': {'thresholds': [0, 1, 10, 50, 500]},
        'Total_Pollen': {
            'thresholds': [0, 10, 30, 60, 100, 200, 500, 1000, 2000, 5000]
        }
    }

def pollen_to_severity(count, thresholds):
    if count == 0 or pd.isna(count):
        return 0
    for i in range(len(thresholds) - 1, 0, -1):
        if count >= thresholds[i]:
            return min(10, i * (10 / (len(thresholds) - 1)))
    return 0
```

---

## Slide 4 — Explanation of Snippet 1
- These biological thresholds for pollen counts are determined from the American Academy of Allergy, Asthma & Immunology (AAAAI).
- Biological thresholds align numeric counts with meaningful exposure bands (Low → Critical), then compress to a consistent 0–10 severity target used across all models.
- This improves interpretability and stabilizes learning compared to raw counts.

---

## Slide 5 — Code Snippet 2
```python
def train_xgboost_for_pollen_type(X_train, y_train, X_test, y_test, pollen_type, use_gpu=True, tune=False):
    if use_gpu:
        try:
            test_model = xgb.XGBRegressor(tree_method='hist', device='cuda', n_estimators=1)
            test_model.fit(X_train[:100], y_train[:100])
            config = get_gpu_xgboost_config()  # device='cuda', early_stopping_rounds=50
        except Exception:
            config = get_gpu_xgboost_config(); config['device'] = 'cpu'
    else:
        config = get_gpu_xgboost_config(); config['device'] = 'cpu'

    # Train with validation for early stopping
    val_split = int(len(X_train) * 0.9)
    X_tr, X_val = X_train[:val_split], X_train[val_split:]
    y_tr, y_val = y_train[:val_split], y_train[val_split:]

    model = xgb.XGBRegressor(**config)
    model.fit(X_tr, y_tr, eval_set=[(X_val, y_val)], verbose=False)
    y_pred = np.clip(model.predict(X_test), 0, 10)
    return model, comprehensive_metrics(y_test, y_pred), y_pred
```

---

## Slide 6 — Explanation of Snippet 2

- Purpose: train an XGBoost regressor per pollen type to predict 0–10 severity.
- Device auto‑selection: attempts a tiny CUDA fit to confirm GPU; falls back to CPU if unavailable.
- Config: uses `get_gpu_xgboost_config()` (hist tree method, early_stopping_rounds=50, regularization params) and sets `device` based on detection.
- Time‑aware validation: reserves the last 10% of the training window as a validation set for early stopping while preserving temporal order.
- Fit loop: trains with `(X_val, y_val)` as eval_set; stops when validation loss plateaus, implicitly selecting the best iteration.
- Prediction post‑processing: clips model outputs to [0, 10] to respect the severity scale.
- Metrics: returns `comprehensive_metrics(...)` including MAE, RMSE, R², weighted MAE, Acc (±1/±2), and high‑day MAE (≥7 severity).
- Optional tuning path (when enabled in the wider script): uses RandomizedSearchCV with TimeSeriesSplit and MAE scoring.

---

## Slide 7 — New Preliminary Result

| Model | MAE | RMSE | R² | Acc (±1) | Acc (±2) |
|---|---:|---:|---:|---:|---:|
| XGBoost Multi-Type (Total Pollen) | 0.517 | 0.775 | 0.879 | 84.8% | 96.1% |
| XGBoost (Baseline) | 0.689 | 0.969 | 0.864 | 75.6% | 94.2% |
| Random Forest (Enhanced) | 0.699 | 0.973 | 0.863 | — | — |
| Random Forest (Baseline) | 0.715 | 0.982 | 0.861 | — | — |
| Weather Only | 1.038 | 1.376 | 0.725 | 56.8% | 85.9% |

---

## Slide 8 — Result Analysis & Next Steps

**Conclusions**  
- Best overall: XGBoost Multi-Type (Total Pollen): MAE 0.517, R² 0.879  
- vs RF baseline from previous milestone: ≈27.8% lower MAE (0.715 → 0.517)  
- The severity-only framing (0–10) works well with XGBoost; biological thresholds + refined features improve accuracy.  
- Multi-type training (Total_Pollen target) outperforms RF and the simpler baseline.

**Next steps**   
- Mobile App: create a mobile application using React Native that takes user data and outputs a forecast using the API.  
- API: expose a simple API that accepts weather + pollen inputs and returns severity (0–10) with top drivers.  